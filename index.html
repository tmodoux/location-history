<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="google-signin-client_id" content="651557588270-a2ko0690vkqho1gk5url4nf0e45v99d6.apps.googleusercontent.com">
  <title>Backup Google Timeline</title>
  <link href="https://fonts.googleapis.com/css?family=Roboto:300" rel="stylesheet">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js" type="text/javascript"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/x2js/1.2.0/xml2json.min.js" type="text/javascript"></script>
  <script src="https://apis.google.com/js/platform.js" async defer></script>
  <script type="text/javascript" src="https://api.pryv.com/lib-javascript/latest/pryv.js"></script>
  <style>
  </style>
</head>
<body>
<h1>Backup Google Timeline</h1>
<span id="pryv-button"></span>
<br>
<div class="g-signin2" data-onsuccess="onSignIn"></div>
<br>
<a href="#" onclick="signOut();">Sign out</a>
<br><br>
<button id="backup">Backup Google Timeline</button>
<br><br>
Upload Google Timeline to the cloud: <input type="file" id="fileInput">
<br><br>
<button id="submit">Send to Pryv</button>
<br><br>
<div id="output"></div>

<script>
var pyConnection;
var batch;
var locationStream = 'google-timeline';
var baseURL = "https://www.google.com/maps/timeline/kml?authuser=0";
var googlePeriod;
var settings = getSettingsFromURL();
var domain = settings.domain || 'pryv.me';
var registerUrl = 'reg.' + domain;
var authSettings = {
  requestingAppId: 'google-timeline-backup',
  requestedPermissions: [
    {
      streamId: locationStream,
      level: 'contribute',
      defaultName: 'Google Timeline'
    }
  ],
  returnURL: 'auto#',
  spanButtonID: 'pryv-button',
  callbacks: {
    initialization: function () {},
    needSignin: onNeedSignin,
    signedIn: onSignedIn,
    refused: function (reason) {},
    error: function (code, message) {}
  }
};


$(document).ready(function() {
  $("#backup").click(backup);
  $("#submit").click(sendToPryv);

  pryv.Auth.config.registerURL = {host: registerUrl, 'ssl': true};
  pryv.Auth.setup(authSettings);

  if (window.File && window.FileReader && window.FileList && window.Blob) {
  // Great success! All the File APIs are supported.
  } else {
    alert('The File APIs are not fully supported in this browser.');
  }
  
  $("#fileInput").on('change', function(e) {
    var file = fileInput.files[0];
    var reader = new FileReader();
    // TODO: check kml type
    reader.onload = function(e) {
      var x2js = new X2JS();
      var jsonObj = x2js.xml_str2json(reader.result);
      var doc = jsonObj.kml.Document;
      var docName = doc.name;
      var placemark = doc.Placemark;
      
      /* Structure of a place:
      {
        name,
        address,
        description,
        TimeSpan: {begin, end},
        Point: {coordinates: "x,y"} OR
        LineString: {coordinates: "x1,y1 0 x2,y2 0 ..."}
      }
      */
      batch = [];
      placemark.map(addPlaceToPryvBatch);
      $("#output").html(JSON.stringify(batch));
    }

    reader.readAsText(file);  
  });
});

function getSettingsFromURL(url) {
  var urlInfo = pryv.utility.urls.parseClientURL(url);
  var queryString = urlInfo.parseQuery();
  var settings = {
    username : url ? urlInfo.username : queryString.username,
    domain: url ? urlInfo.domain: queryString.domain,
    auth: url ? urlInfo.parseSharingTokens()[0]: queryString.auth
  };
  return settings;
}

function onNeedSignin(popupUrl, pollUrl, pollRateMs) {
  pyConnection = null;
}

function onSignedIn(connection, langCode) {
  pyConnection = connection;
  // Get last sync time
  var filter = new pryv.Filter({limit : 1});
  pyConnection.events.get(filter, function (err, events) {
    var lastSync = events[0].time;
    console.log('Last sync: '+lastSync);
    googlePeriod = getGooglePeriod(lastSync);
  });
}

function addPlaceToPryvBatch(place) {
  var description = 
    'Name: ' + place.name + ' - ' +
    'Address: ' + place.address + ' - ' +
    'Description : ' + place.description;
  
  var [startCoord, endCoord] = parseCoordinates(place);
  var [startTime, endTime] = parseTimes(place);
  
  var events = [
    createLocationEvent(startTime, startCoord, description),
    createLocationEvent(endTime, endCoord, description)
  ];
  
  events.forEach(function (event) {
    batch.push({
      method: 'events.create',
      params: event
    });
  });
}

function parseCoordinates(place) {
  var coordinatesObj = place.Point || place.LineString;
  // TODO: maybe need stronger regexp here
  var coordinates = coordinatesObj.coordinates.split(",0");
  
  // Coordinates can correspond to:
  // 1. A travel: several points of coordinates along the route
  //    then we extract start and end coordinates (ignore the ones inbetween)
  // 2. A stay: only one fixed point of coordinates
  //    then we set end coordinates as equal to start
  var startCoord = coordinates[0].split(",");
  var endCoord = coordinates[1] === "" ? startCoord: coordinates[1].split(",");
  
  return [
    parseFloatArray(startCoord),
    parseFloatArray(endCoord)
  ];
}

function parseTimes(place) {
  var times = place.TimeSpan;
  // Time format: 2018-02-02T15:06:10.404Z
  return [
    times.begin,
    times.end
  ].map(getPryvTimestamp);
}

function getPryvTimestamp (dateString) {
  return new Date(dateString).getTime()/1000;
}

function getGooglePeriod (lastSync) {
  var fromTime = getGoogleTime(lastSync);
  var toTime = getGoogleTime();
  return 'pb=!1m8!1m3'+fromTime+'!2m3'+toTime;
}

function getGoogleTime (timestamp) {
  var date = timestamp ? new Date(timestamp): new Date();
  var year = date.getFullYear();
  var month = date.getMonth();
  var day = date.getDate();
  return '!1i'+year+'!2i'+month+'!3i'+day;  
}

function createLocationEvent(time, coord, desc) {
  return {
    streamId: locationStream,
    type: 'position/wgs84',
    description: desc,
    time: time,
    content: {
      longitude: coord[0],
      latitude: coord[1]
    }
  };
}

function parseFloatArray(stringArray) {
  return stringArray.map(function (stringElem) {
    return parseFloat(stringElem);
  })
}

var backup = function() {
  console.log('Google period: ' + googlePeriod);
  window.open(baseURL+'&'+googlePeriod);
};

var onSignIn = function(googleUser) {
  var profile = googleUser.getBasicProfile();
  console.log('ID: ' + profile.getId()); // Do not send to your backend! Use an ID token instead.
  console.log('Name: ' + profile.getName());
  console.log('Image URL: ' + profile.getImageUrl());
  console.log('Email: ' + profile.getEmail()); // This is null if the 'email' scope is not present.
};

var signOut = function() {
  var auth2 = gapi.auth2.getAuthInstance();
  auth2.signOut().then(function () {
    console.log('User signed out.');
  });
};

var sendToPryv = function() {
  if (pyConnection) {
    pyConnection.batchCall(batch, function (err, res) { 
    });
  } else {
    alert('Login with a Pryv account first!');
  }
};
</script>
</body>
</html>